# Reporting data results #2-ng

[Download](https://github.com/geanders/RProgrammingForResearch/raw/master/slides/CourseNotes_Week8.pdf) a pdf of the lecture slides covering this topic.

```{r caa, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_knit$set(error = TRUE)
library(tidyverse)
library(knitr)
library(faraway)
data(worldcup)
library(ggthemes)
library(lubridate)
library(gridExtra)
library(titanic)
data(titanic_train)
```

---

## Matrices

A matrix is like a data frame, but all the values in all columns must be of the same class (e.g., numeric, character). 

R uses matrices a lot for its underlying math (e.g., for the linear algebra operations required for fitting regression models). R can do matrix operations quite quickly.

You can create a matrix with the `matrix` function. Input a vector with the values to fill the matrix and `ncol` to set the number of columns:

```{r cab}
foo <- matrix(1:10, ncol = 5)
foo
```

By default, the matrix will fill up by column. You can fill it by row with the `byrow` function: 

```{r cac}
foo <- matrix(1:10, ncol = 5, byrow = TRUE)
foo
```

In certain situations, you might want to work with a matrix instead of a data frame (for example, in cases where you were concerned about speed -- a matrix is more memory efficient than the corresponding data frame). If you want to convert a data frame to a matrix, you can use the `as.matrix` function: 

```{r cad}
foo <- data.frame(col_1 = 1:2, col_2 = 3:4,
                  col_3 = 5:6, col_4 = 7:8,
                  col_5 = 9:10)
(foo <- as.matrix(foo))
```

You can index matrices with square brackets, just like data frames: 

```{r cae}
foo[1, 1:2]
```

You cannot, however, use `dplyr` functions with matrices: 

```{r caf, eval = FALSE}
foo %>% filter(col_1 == 1)
```
```
Error in UseMethod("filter_") : 
  no applicable method for 'filter_' applied to
  an object of class "c('matrix', 'integer',
  'numeric')"
```

All elements in a matrix must have the same class. \bigskip

The matrix will default to make all values the most general class of any of the values, in any column. For example, if we replaced one numeric value with the character "a", everything would turn into a character:

```{r cag}
foo[1, 1] <- "a"
foo
```

---

## Regular expressions

For these examples, we'll use some data on passengers of the Titanic. You can load this data using:

```{r}
# install.packages("titanic")
library(titanic)
data("titanic_train")
```

We will be using the `stringr` package:

```{r}
library(stringr)
```

This data includes a column called "Name" with passenger names. This column is somewhat messy and includes several elements that we might want to separate (last name, first name, title). Here are the first few values of "Name": 

```{r}
titanic_train %>% select(Name) %>% slice(1:3)
```

We've already done some things to manipulate strings. For example, if we wanted to separate "Name" into last name and first name (including title), we could actually do that with the `separate` function: 

```{r}
titanic_train %>% 
  select(Name) %>% 
  slice(1:3) %>% 
  separate(Name, c("last_name", "first_name"), sep = ", ")
```


Notice that `separate` is looking for a regular pattern (", ") and then doing something based on the location of that pattern in each string (splitting the string). \bigskip

There are a variety of functions in R that can perform manipulations based on finding regular patterns in character strings. 


The `str_detect` function will look through each element of a character vector for a designated pattern. If the pattern is there, it will return `TRUE`, and otherwise `FALSE`. The convention is: 

```
## Generic code
str_detect(string = [vector you want to check], 
           pattern = [pattern you want to check for])
```

For example, to create a logical vector specifying which of the Titanic passenger names include "Mrs.", you can call:

```{r}
mrs <- str_detect(titanic_train$Name, "Mrs.")
head(mrs)
```


The result is a logical vector, so `str_detect` can be used in `filter` to subset data to only rows where the passenger's name includes "Mrs.":

```{r}
titanic_train %>%
  filter(str_detect(Name, "Mrs.")) %>%
  select(Name) %>%
  slice(1:3)
```


There is an older, base R function called `grepl` that does something very similar (although note that the order of the arguments is reversed).

```{r}
titanic_train %>%
  filter(grepl("Mrs.", Name)) %>%
  select(Name) %>%
  slice(1:3)
```

The `str_extract` function can be used to extract a string (if it exists) from each value in a character vector. It follows similar conventions to `str_detect`:

```
## Generic code
str_extract(string = [vector you want to check], 
           pattern = [pattern you want to check for])
```


For example, you might want to extract "Mrs." if it exists in a passenger's name:

```{r}
titanic_train %>%
  mutate(mrs = str_extract(Name, "Mrs.")) %>%
  select(Name, mrs) %>%
  slice(1:3)
```

Notice that now we're creating a new column (`mrs`) that either has "Mrs." (if there's a match) or is missing (`NA`) if there's not a match. 


For this first example, we were looking for an exact string ("Mrs"). However, you can use patterns that match a particular pattern, but not an exact string. For example, we could expand the regular expression to find "Mr." or "Mrs.": 

```{r}
titanic_train %>%
  mutate(title = str_extract(Name, "Mr\\.|Mrs\\.")) %>%
  select(Name, title) %>%
  slice(1:3)
```

Note that this pattern uses a special operator (`|`) to find one pattern **or** another. Double backslashes (`\\`) **escape** the special character ".". 


As a note, in regular expressions, all of the following characters are special characters that need to be escaped with backslashes if you want to use them literally: 

```
. * + ^ ? $ \ | ( ) [ ] { }
```


Notice that "Mr." and "Mrs." both start with "Mr", end with ".", and may or may not have an "s" in between. 

```{r}
titanic_train %>%
  mutate(title = str_extract(Name, "Mr(s)*\\.")) %>%
  select(Name, title) %>%
  slice(1:3)
```

This pattern uses `(s)*` to match zero or more "s"s at this spot in the pattern. 


In the previous code, we found "Mr." and "Mrs.", but missed "Miss.". We could tweak the pattern again to try to capture that, as well. For all three, we have the pattern that it starts with "M", has some lowercase letters, and then ends with ".".  

```{r}
titanic_train %>%
  mutate(title = str_extract(Name, "M[a-z]+\\.")) %>%
  select(Name, title) %>%
  slice(1:3)
```


The last pattern used `[a-z]+` to match one or more lowercase letters. The `[a-z]`is a **character class**. \bigskip 

You can also match digits (`[0-9]`), uppercase letters (`[A-Z]`), just some letters (`[aeiou]`), etc. \bigskip

You can negate a character class by starting it with `^`. For example, `[^0-9]` will match anything that **isn't** a digit. 


Sometimes, you want to match a pattern, but then only subset a part of it. For example, each passenger seems to have a title ("Mr.", "Mrs.", etc.) that comes after ", " and before ". ". We can use this pattern to find the title, but then we get some extra stuff with the match: 

```{r}
titanic_train %>%
  mutate(title = str_extract(Name, ",\\s[A-Za-z]*\\.\\s")) %>%
  select(title) %>%
  slice(1:3)
```

As a note, in this pattern, `\\s` is used to match a space. 


We are getting things like ", Mr. ", when we really want "Mr". We can use the `str_match` function to do this. We group what we want to extract from the pattern in parentheses, and then the function returns a matrix. The first column is the full pattern match, and each following column gives just what matches within the groups. 

```{r}
head(str_match(titanic_train$Name,
          pattern = ",\\s([A-Za-z]*)\\.\\s"))
```


To get just the title, then, we can run:

```{r}
titanic_train %>%
  mutate(title = 
           str_match(Name, ",\\s([A-Za-z]*)\\.\\s")[ , 2]) %>%
  select(Name, title) %>%
  slice(1:3)
```

The `[ , 2]` pulls out just the second column from the matrix returned by `str_match`. 


Here are some of the most common titles: 

```{r}
titanic_train %>%
  mutate(title = 
           str_match(Name, ",\\s([A-Za-z]*)\\.\\s")[ , 2]) %>%
  group_by(title) %>% summarize(n = n()) %>%
  arrange(desc(n)) %>% slice(1:5)
```


Here are a few other examples of regular expressions in action with this dataset. \bigskip

Get just names that start with ("^") the letter "A":

```{r}
titanic_train %>%
  filter(str_detect(Name, "^A")) %>%
  select(Name) %>%
  slice(1:3)
```


Get names with "II" or "III" (`{2,}` says to match at least two times):

```{r}
titanic_train %>%
  filter(str_detect(Name, "I{2,}")) %>%
  select(Name) %>%
  slice(1:3)
```


Get names with "Andersen" or "Anderson" (alternatives in square brackets):

```{r}
titanic_train %>%
  filter(str_detect(Name, "Anders[eo]n")) %>%
  select(Name)
```



Get names that start with ("^" outside of brackets) the letters "A" and "B":

```{r}
titanic_train %>%
  filter(str_detect(Name, "^[AB]")) %>%
  select(Name) %>%
  slice(1:3)
```


Get names that end with ("$") the letter "b" (either lowercase or uppercase):

```{r}
titanic_train %>%
  filter(str_detect(Name, "[bB]$")) %>%
  select(Name) 
```


Some useful regular expression operators include: 

```{r echo = FALSE}
reg_exp <- data_frame("Operator" = c(".",
                                     "*",
                                     "*?",
                                     "+",
                                     "+?",
                                     "^",
                                     "$", 
                                     "[...]"),
                      "Meaning" = c("Any character", 
                                    "Match 0 or more times (greedy)",
                                    "Match 0 or more times (non-greedy)",
                                    "Match 1 or more times (greedy)",
                                    "Match 1 or more times (non-greedy)",
                                    "Starts with (in brackets, negates)",
                                    "Ends with",
                                    "Character classes"))
knitr::kable(reg_exp)
```


For more on these patterns, see: 

- Help file for the `stringi-search-regex` function in the `stringi` package (which should install when you install `stringr`)
- [Introduction to stringr](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html) by Hadley Wickham
- [Handling and Processing Strings in R](http://gastonsanchez.com/Handling_and_Processing_Strings_in_R.pdf) by Gaston Sanchez (seven chapter ebook)
- http://gskinner.com/RegExr and http://www.txt2re.com: Interactive tools for helping you build regular expression pattern strings

---

## Point maps

It is very easy now to create point maps in R based on longitude and latitude values of specific locations. You can use the `map_data` function from the `ggplot2` package to pull data for maps at different levels ("usa", "state", "world", "county").

The maps you pull using `map_data` are just data to use to plot polygon shapes for areas like states and counties. 

```{r cau, warning = FALSE, message = FALSE}
library(ggplot2)
us_map <- map_data("state")
head(us_map, 3)
```

You can add points to these based on latitude and longitude.

Mapping uses the `long` and `lat` columns from this data for location:

```{r cav, fig.width = 6, fig.height = 2.5, fig.align = "center"}
north_carolina <- us_map %>% 
  filter(region == "north carolina")
ggplot(north_carolina, aes(x = long, y = lat)) +
  geom_point()
```

If you try to plot lines, however, you'll have a problem:

```{r caw, fig.width = 3.5, fig.height = 2.25, fig.align = "center"}
carolinas <- us_map %>% 
  filter(str_detect(region, "carolina"))
ggplot(carolinas, aes(x = long, y = lat)) + 
  geom_path()
```

The `group` column fixes this problem. It will plot a separate path or polygon for each separate group. For mapping, this gives separate groupings for mainland versus islands and for different states:

```{r cax}
carolinas %>%
  group_by(group) %>%
  slice(1)
```

Using `group = group` avoids the extra lines from the earlier map:

```{r cay, fig.width = 3.5, fig.height = 2.25, fig.align = "center"}
ggplot(carolinas, aes(x = long, y = lat,
                      group = group)) + 
  geom_path()
```

To plot filled regions, use `geom_polygon` with `fill = region`. Also, the "void" theme is often useful when mapping:

```{r caz, fig.width = 4.5, fig.height = 2, fig.align = "center"}
ggplot(carolinas, aes(x = long, y = lat,
                      group = group,
                      fill = region)) + 
  geom_polygon(color = "black") + 
  theme_void() + 
  coord_map()
```

Here is an example of plotting all of the US by state:

```{r cba}
map_1 <- ggplot(us_map, aes(x = long, y = lat,
                            group = group)) + 
        geom_polygon(fill = "dodgerblue",
                     color = "white") +
        theme_void() + 
  coord_map()
```

```{r cbb, fig.width = 6.5, fig.height = 4, fig.align = "center"}
map_1
```

To add points to these maps, you can use `geom_point`, again using longitude and latitude to define position. \bigskip

Here I'll use an example of data points related to the story told in last year's ["Serial" podcast](http://serialpodcast.org). 

```{r cbc}
serial <- read.csv("data/serial_map_data.csv")
head(serial, 3)
```

[David Robinson](https://github.com/dgrtwo/serial-ggvis/blob/master/serial-preprocessing.Rmd) figured out a way to convert the x and y coordinates in this data to latitude and longitude coordinates. I'm also adding a column for whether of not the point is a cell tower.

```{r cbd, message = FALSE, warning = FALSE}
serial <- serial %>%
    mutate(long = -76.8854 + 0.00017022 * x,
           lat  = 39.23822 + 1.371014e-04 * y,
           tower = Type == "cell-site")
```

```{r cbe, message = FALSE, warning = FALSE}
serial[c(1:2, (nrow(serial) - 1):nrow(serial)), 
       c("Type", "Name", "long", "lat", "tower")]
```

Now I can map just Baltimore City and Baltimore County in Maryland and add these points. I used `map_data` to pull the "county" map and specified "region" as "maryland", to limit the map just to Maryland counties. 

```{r cbf}
baltimore <- map_data('county', region = 'maryland')
head(baltimore, 3)
```

From that, I subset out rows where the `subregion` column was "baltimore city" or "baltimore". 

```{r cbg}
baltimore <- subset(baltimore, 
                    subregion %in% c("baltimore city",
                                     "baltimore"))
head(baltimore, 3)
```

I used `geom_point` to plot the points. `ggplot` uses the `group` column to group together counties, but we don't need that in the points, so I needed to set `group = NA` in the `geom_point` statement. I put `color = tower` inside the `aes` statement so that the points would be one color for cell towers and another color for everything else. 

```{r cbh}
balt_plot <- ggplot(baltimore, 
                    aes(x = long, y = lat, group = group)) + 
        geom_polygon(fill = "lightblue", color = "black") +
        geom_point(data = serial, aes(x = long, y = lat,
                                      group = NA,
                                      color = tower)) + 
        theme_bw()
```

```{r cbi, fig.width = 7, fig.height = 4}
balt_plot + 
  coord_map()
```

## Choropleth maps

There's a fantastic new(-ish) package in R to plot choropleth maps. You could also plot choropleths using `ggplot` and other mapping functions, but I would strongly recommend this new package if you're mapping the US. 

You will need to install and load the `choroplethr` package in R to use the functions below.

```{r cbj, message = FALSE, warning = FALSE}
# install.packages("choroplethr")
library(choroplethr)

# install.packages("choroplethrMaps")
library(choroplethrMaps)
```

At the most basic level, you can use this package to plot some data that comes automatically with the package (you'll just need to load the data using the `data` function). For example, if you wanted to plot state-by-state populations as of 2012, you could use:

```{r cbk, warning = FALSE, message=FALSE}
data(df_pop_state)
map_3 <- state_choropleth(df_pop_state)
```

```{r cbl, fig.width=8, fig.height=3.5}
map_3 
```

You can find out more about the `df_pop_state` data if you type `?df_pop_state`. Notice that, for the data frame, the location is given in a column called `region` and the population size to plot is in a column called `value`. 

```{r cbm}
head(df_pop_state, 3)
```

You could use this function to create any state-level choropleth you wanted, as long as you could create a data frame with a column for states called `region` and a column with the value you want to show called `value`.

You can run similar functions at different spatial resolutions (for example, county or zip code):

```{r cbn}
data(df_pop_county)
head(df_pop_county, 3)
```

You can plot choropleths at this level, as well:

```{r cbo, warning = FALSE, message = FALSE}
map_4 <- county_choropleth(df_pop_county)
```

```{r cbp, fig.width=8, fig.height=4}
map_4
```

You can even do this for countries of the world:

```{r cbq, fig.width = 8, fig.height = 3.5, warning=FALSE, message=FALSE}
data(df_pop_country)
country_choropleth(df_pop_country)
```

You can zoom into states or counties. For example, to plot population by county in Colorado, you could run:

```{r cbr, fig.width = 6, fig.height = 3, message = FALSE, warning = FALSE}
county_choropleth(df_pop_county, state_zoom = "colorado")
```

You can also use this package to map different tables from the US Census' American Community Survey. 

The package includes the `choroplethr_acs()` function to do this, with an option for which level of map you want (`map = `, choices are "state", "country", and "zip"). If you want to map at the state level, for example, use `state_choroplethr_acs()` (other options are county level and zip code level). 

These functions pull recent Census data directly from the US Census using its API, so they require you to get an API key, which you can get [here](http://api.census.gov/data/key_signup.html). \bigskip

Once you put in your request, they'll email you your key. Once they give you your API key, you'll need to install it on R:

```{r cbs, echo = FALSE, message = FALSE, warning = FALSE, eval = FALSE}
library(acs)
api.key.install(Sys.getenv("acskey"))
```

```{r cbt, eval = FALSE}
library(acs)
api.key.install('[your census api key]');
```

You can pick from a large number of American Community Survey tables-- [see here](http://factfinder.census.gov/faces/affhelp/jsf/pages/metadata.xhtml?lang=en&type=dataset&id=dataset.en.ACS_12_5YR) for the list plus ID numbers. If the table has multiple columns, you will be prompted to select which one you want to plot. 

For example, table B19301 gives per-capita income, so if you wanted to plot that, you could run:

```{r cbu, fig.width = 3, fig.height = 2.75, message = FALSE, eval = FALSE, eval = FALSE}
county_choropleth_acs(tableId = "B19301",
                       state_zoom = c("wyoming",
                                      "colorado"))

```

```{r cbv, fig.width = 10, fig.height = 6, message = FALSE, echo = FALSE, fig.align = "center", eval = FALSE, eval = FALSE}
ex_choro <- county_choropleth_acs(tableId = "B19301",
                       state_zoom = c("wyoming",
                                      "colorado"))
save(ex_choro, file = "data/example_choropleth.Rdata")

```

```{r cbw, echo = FALSE, fig.width = 10, fig.height = 6, message = FALSE, fig.align = "center", eval = FALSE, eval = FALSE}
load("data/example_choropleth.Rdata")
ex_choro
```


## Google Maps API

The `ggmap` package allows you to use tools from Google Maps directly from R.

```{r cbx, message=FALSE, warning = FALSE}
## install.packages("ggmap")
library(ggmap)
```

This package uses the Google Maps API, so you should read their [terms of service](http://developers.google.com/maps/terms) and make sure you follow them. In particular, you are limited to just a certain number of queries per time. 

You can use the `get_map` function to get maps for different locations. You can either use the longitude and latitude of the center point of the map, along with the `zoom` option to say how much to zoom in (3: continent to 20: building) or you can use a character string to specify a location. 

If you do the second, `get_map` will actually use the Google Maps API to geocode the string to a latitude and longitude and then get the map (you can imagine that this is like searching in Google Maps in the search box for a location).

```{r cby, message = FALSE, warning = FALSE, fig.width = 3.5, fig.height = 3.5, fig.align = "center"}
beijing <- get_map("Beijing", zoom = 12)
ggmap(beijing)
```

With this package, you can get maps from the following different sources:

- Google Maps
- OpenStreetMap
- Stamen Maps
- CloudMade Maps (You may need a separate API key for this)

Here are different examples of Beijing using different map sources. (Also, note that I'm using the option `extent = "device"` to fill up the whole plot are with the map, instead of including axis labels and titles.)

```{r cca, message = FALSE, warning = FALSE, eval = FALSE}
beijing_a <- get_map("Beijing", zoom = 12,
                     source = "stamen", maptype = "toner")
a <- ggmap(beijing_a, extent = "device")

beijing_b <- get_map("Beijing", zoom = 12,
                     source = "stamen", maptype = "watercolor")
b <- ggmap(beijing_b, extent = "device")

beijing_c <- get_map("Beijing", zoom = 12,
                     source = "google", maptype = "hybrid")
c <- ggmap(beijing_c, extent = "device")
```

```{r ccb, fig.width = 7, eval = FALSE}
grid.arrange(a, b, c, nrow = 1) 
```

As with the maps from `ggplot2`, you can add points to these maps:

```{r cce, warning = FALSE, message = FALSE, eval = FALSE}
serial_phone <- read.csv("data/serial_phone_data.csv") %>% 
        mutate(Cell_Site = substring(Cell_Site, 1, 4),
               Call_Time = as.POSIXct(Call_Time, format = "%d/%m/%y %H:%M",
                                      tz = "EST")) %>%
        left_join(serial, by = c("Cell_Site" = "Name")) %>%
        select(Person_Called, Call_Time, Duration, long, lat) %>%
        filter(!(Person_Called %in% c("incoming", "# + Adnan cell"))) %>%
        arrange(Call_Time)
```

```{r ccf, message = FALSE, warning = FALSE, fig.width = 5, eval = FALSE}
serial_map <- get_map(c(-76.7, 39.3), zoom = 12,
                      source = "stamen",
                      maptype = "toner")
serial_map <- ggmap(serial_map, extent = "device") + 
        geom_point(data = serial_phone,
                   aes(x = long, y = lat),
                   color = "red", size = 3,
                   alpha = 0.4) +
        geom_point(data = subset(serial,
                                 Type != "cell-site"),
                   aes(x = long, y = lat),
                   color = "darkgoldenrod1",
                   size = 2)
```

```{r ccg, warning = FALSE, message = FALSE, fig.width = 4, fig.height = 4, fig.align = "center", echo = FALSE, eval = FALSE}
serial_map
```

You can also use the Google Maps API, through the `geocode` function, to get the latitude and longitude of specific locations. Basically, if the string would give you the right location if you typed it in Google Maps, `geocode` should be able to geocode it.

For example, you can get the location of CSU:

```{r cch, message = FALSE, warning = FALSE, eval = FALSE}
geocode("Colorado State University")
```

You can also get a location by address:

```{r cci, message = FALSE, warning = FALSE, eval = FALSE}
geocode("1 First St NE, Washington, DC")
```

You can get distances, too, using the `mapdist` function with two locations. This will give you distance and also time. 

```{r ccj, message = FALSE, warning = FALSE, eval = FALSE}
mapdist("Fort Collins CO",
        "1 First St NE, Washington, DC") %>%
  select(from, miles, hours)
```

## String operations

The `str_trim` function from the `stringr` package allows you to trim leading and trailing white space: 

```{r cck}
with_spaces <- c("    a ", "  bob", " gamma")
with_spaces
str_trim(with_spaces)
```

This is rarer, but if you ever want to, you can add leading and/or trailing white space to elements of a character vector with `str_pad` from the `stringr` package.

There are also functions to change a full character string to uppercase, lowercase, or title case: 

```{r ccl}
titanic_train$Name[1]
str_to_upper(titanic_train$Name[1])
str_to_lower(titanic_train$Name[1])
str_to_title(str_to_lower(titanic_train$Name[1]))
```

## In-course exercise

This exercise will continue using the Fatality Analysis Reporting System (FARS) data we started using last week. 

```{r ccm, echo = FALSE, message = FALSE, warning = FALSE}
library(dplyr)
library(tidyr)
library(readr)
library(lubridate)

state_fips <- read_delim("http://www2.census.gov/geo/docs/reference/state.txt",
                         delim = "|") %>%
  dplyr::rename(state = STATE,
         state_name = STATE_NAME) %>%
  dplyr::select(state, state_name) %>%
  dplyr::mutate(state = as.integer(state))

accident <- read_csv("data/accident.csv") %>%
  dplyr::select(STATE, DAY:MINUTE, DRUNK_DR) %>%
  dplyr::rename(state = STATE, 
                drunk_dr = DRUNK_DR) %>%
  dplyr::select(-DAY_WEEK) %>%
  tidyr::unite(date, DAY:MINUTE, sep = "-") %>%
  dplyr::mutate(date = dmy_hm(date), 
                drunk_dr = drunk_dr >= 1, 
                daytime = hour(date) %in% c(7:19), 
                month = month(date)) %>%
  dplyr::filter(!is.na(date)) %>%
  dplyr::left_join(state_fips, by = "state")
```

### Using a function and `purrr` to create state-specific plots

The first part of this week's in-course exercise continues last week's exercise. You will write a function to create state-specific plots from this data, then use it to create plots for the states of Colorado, Texas, California, and New York. 

- The FARS data includes a column called `STATE`, but it gives state as a one- or two-digit code, rather than by name. These codes are the state Federal Information Processing Standard (FIPS) codes. A dataset with state names and FIPS codes is available at http://www2.census.gov/geo/docs/reference/state.txt. Read that data into an R object called `state_fips` and clean it so the first few lines look like this (hint: to change the `state` column to an integer class, you can use the function `as.integer`): 

```{r check11a, echo = FALSE, warning = FALSE, message = FALSE}
state_fips <- read_delim("http://www2.census.gov/geo/docs/reference/state.txt",
                         delim = "|") %>%
  rename(state = STATE,
         state_name = STATE_NAME) %>%
  select(state, state_name) %>%
  mutate(state = as.integer(state))
state_fips %>% slice(1:5)
```

- Read the 2015 FARS data into an R object named `accident`. Use all the date and time information to create a column named `date` with the date and time of the accident. Include information on whether the accident was related to drunk driving (FALSE if there were 0 drunk drivers, TRUE if there were one or more), and create columns that gives whether the accident was during the day (7 AM to 7 PM) or not as well as the month of the accident (for this last column, you can either retain it from the original data or recalculate it based on the new `date` variable). Filter out any values where the date-time does not render (i.e., `date` is a missing value). The first few rows of the cleaned dataframe should look like this:

```{r check10a, warning = FALSE, message = FALSE, echo = FALSE}
accident <- read_csv("data/accident.csv") %>%
  select(STATE, DAY:MINUTE, DRUNK_DR) %>%
  rename(state = STATE, 
         drunk_dr = DRUNK_DR) %>%
  select(-DAY_WEEK) %>%
  unite(date, DAY:MINUTE, sep = "-") %>%
  mutate(date = dmy_hm(date), 
         drunk_dr = drunk_dr >= 1,
         daytime = hour(date) %in% c(7:19),
         month = month(date)) %>%
  filter(!is.na(date))
accident %>% slice(1:5)
```

- Join the information from `state_fips` into the `accident` dataframe. There may be a few locations in the `state_fips` dataframe that are not included in the `accident` dataframe (e.g., Virgin Islands), so when you join keep all observations in `accident` but only the observations in `state_fips` that match at least one row of `accident`. The first few rows of the joined dataset should look like this: 

```{r echo = FALSE}
accident <- accident %>%
  left_join(state_fips, by = "state")
accident %>% slice(1:5)
```

- Summarize the data to get the total number of accidents in Colorado in each month, separated by (1) daytime and nighttime and (2) related or unrelated to drunk driving  (in other words, in January, how many daytime accidents were there that were unrelated to drunk driving? How many nighttime accidents that were unrelated to drunk driving? etc.). The summarized data should look like this:

```{r echo = FALSE}
accident %>%
  filter(state_name == "Colorado") %>%
  group_by(daytime, month, drunk_dr) %>%
  summarize(accidents = n())
```

- Write a function that inputs a dataframe (`df`) and outputs this type of summary dataframe (like the one just created for Colorado) for whatever data is in the input dataframe. Below are some examples of how this function should work: 

```{r echo = FALSE}
summarize_fars <- function(df){
  df %>%
    group_by(daytime, month, drunk_dr) %>%
    summarize(accidents = n())
}
```

```{r}
colorado_data <- accident %>% 
  filter(state_name == "Colorado")
 
colorado_summary <- summarize_fars(df = colorado_data)
head(colorado_summary)

# Note also that you can pipe with the new function:
accident %>% 
  filter(state_name == "Texas") %>% 
  summarize_fars() %>% 
  tbl_df() %>% 
  slice(1:3)
```

- Once you've written the function, see if you can figure out what the following code does. How does the new function fit in? (Note: We could have achieved the same thing with basic `dplyr` code, but this framework will allow you to ultimately do a lot more than you can with `dplyr`.)

```{r eval = FALSE}
library(purrr)

accident %>% 
  filter(state_name %in% c("Colorado", "Texas", "California", "New York")) %>% 
  group_by(state_name) %>%
  nest() %>% 
  mutate(summary = map(data, summarize_fars)) %>% 
  select(-data) %>% 
  unnest() 
```

- Write code to create boxplots for Colorado of the distribution of total accidents within each month. Create separate boxplots for daytime and nighttime accidents, and facet by whether the accident was related to drunk driving. The plot should look like the plot below. 

```{r check9a, echo = FALSE, fig.width = 6, fig.height = 3, fig.align = "center"}
library(ggplot2)
accident %>%
  filter(state_name == "Colorado") %>%
  mutate(drunk_dr = factor(drunk_dr, labels = c("Unrelated to\ndrunk driving",
                                                "Related to\ndrunk driving")),
         daytime = factor(daytime, labels = c("Nighttime", "Daytime"))) %>%
  group_by(daytime, month, drunk_dr) %>%
  summarize(accidents = n()) %>%
  ggplot(aes(x = daytime, y = accidents, group = daytime)) + 
  geom_boxplot() + 
  facet_wrap(~ drunk_dr, ncol = 2) +
  xlab("Time of day") + ylab("# of monthly accidents") + 
  ggtitle(paste("Fatal accidents in", "Colorado", "in 2015"))
```

- Now write a function called `plot_fars` to create a plot like the one you just made for Colorado for any dataframe with the format of `accident` (i.e., same number, types, and names of columns). Test it on subsets of the data for several states (Colorado, Texas, California, and New York). (*Hint*: To get a function to print out a plot created with ggplot, you will need to explicitly print the output from your function. See the examples of using the function below.) 

```{r check8a, echo = FALSE, fig.width = 6, fig.height = 3, fig.align = "center"}
plot_fars <- function(df){
  fars_plot <- df %>%
    mutate(drunk_dr = factor(drunk_dr, labels = c("Unrelated to\ndrunk driving",
                                                  "Related to\ndrunk driving")),
           daytime = factor(daytime, labels = c("Nighttime", "Daytime"))) %>%
    group_by(daytime, month, drunk_dr) %>%
    summarize(accidents = n()) %>%
    ggplot(aes(x = daytime, y = accidents, group = daytime)) +
    geom_boxplot() +
    facet_wrap(~ drunk_dr, ncol = 2) +
    xlab("Time of day") + ylab("# of monthly accidents") 
}
```


Here are some examples of what should happen when you run this function:

```{r, fig.width = 6, fig.height = 3, fig.align = "center"}
co_plot <- plot_fars(df = filter(accident, state_name == "Colorado"))
print(co_plot)

accident %>% 
  filter(state_name == "Texas") %>% 
  plot_fars() %>% 
  print()
```

- Once you have written this function, what happens when you run the following code?

```{r eval = FALSE, fig.width = 6, fig.height = 3, fig.align = "center"}
library(purrr)

state_plots <- accident %>% 
  filter(state_name %in% c("Colorado", "Texas", "California", "New York")) %>% 
  group_by(state_name) %>%
  nest() %>% 
  mutate(plots = map(data, plot_fars)) 

class(state_plots[["plots"]])
class(state_plots[["plots"]][[1]])
print(state_plots[["plots"]][[1]])$plot
```

- Install the `cowplot` package (this is a `ggplot2` extension) and then try running the following code. What happens when you run this code?

```{r eval = FALSE}
library(cowplot)
plot_grid(plotlist = state_plots[["plots"]], 
          ncol = 2, labels = "AUTO")
```

#### Example R code

Here is the code to read the dataset with state names and FIPS codes at http://www2.census.gov/geo/docs/reference/state.txt into an R object called `state_fips` and clean it so the first few lines: 

```{r check7a, echo = FALSE, warning = FALSE, message = FALSE}
state_fips <- read_delim("http://www2.census.gov/geo/docs/reference/state.txt",
                         delim = "|") %>%
  rename(state = STATE,
         state_name = STATE_NAME) %>%
  select(state, state_name) %>%
  mutate(state = as.integer(state))
state_fips %>% slice(1:5)
```

Note that you can read this file directly from the website using `read_delim`. 

Read the 2015 FARS data into an R object named `accident`. Use all the date and time information to create a column named `date` with the date and time of the accident. Include information on whether the accident was related to drunk driving (FALSE if there were 0 drunk drivers, TRUE if there were one or more), and create columns that gives whether the accident was during the day (7 AM to 7 PM) or not as well as the month of the accident (for this last column, you can either retain it from the original data or recalculate it based on the new `date` variable). Filter out any values where the date-time does not render (i.e., `date` is a missing value). You can use the following code to do all this:

```{r check6a, warning = FALSE, message = FALSE, echo = FALSE}
accident <- read_csv("data/accident.csv") %>%
  select(STATE, DAY:MINUTE, DRUNK_DR) %>%
  rename(state = STATE, 
         drunk_dr = DRUNK_DR) %>%
  select(-DAY_WEEK) %>%
  unite(date, DAY:MINUTE, sep = "-") %>%
  mutate(date = dmy_hm(date), 
         drunk_dr = drunk_dr >= 1,
         daytime = hour(date) %in% c(7:19),
         month = month(date)) %>%
  filter(!is.na(date))

accident %>% slice(1:5)
```

A few notes: 

- Notice that `select` is using the `:` operator to pick several columns in a row.
- Some of the column names in all caps are changed to lower case to make them easier to work with. 
- The `DAY_WEEK` column is in the middle of other date columns, but if you remove it, you can use `unite` with `:` to join together all the date-time columns and then use `lubridate` to change this column into the right class. 
- A logical operator is used inside a `mutate` call to create a column of whether the accident involved drunk driving (one or more drunk drivers involved)
- The `hour` function from `lubridate` is used to check if the time of the accident falls in "daytime" or not
- Some of the accidents are missing some date information. A `filter` is used to filter that out. 

Join the information from `state_fips` into the `accident` dataframe. There may be a few locations in the `state_fips` dataframe that are not included in the `accident` dataframe (e.g., Virgin Islands), so when you join keep all observations in `accident` but only the observations in `state_fips` that match at least one row of `accident`. You can use the following code for this: 

```{r echo = FALSE}
accident <- accident %>%
  left_join(state_fips, by = "state")

accident %>% slice(1:5)
```

Summarize the data to get the total number of accidents, separated by (1) daytime and nighttime and (2) related or unrelated to drunk driving, in each month (in other words, in January, how many daytime accidents were there that were unrelated to drunk driving? How many nighttime accidents that were unrelated to drunk driving? etc.). You can do that with this code:

```{r}
accident %>%
  filter(state_name == "Colorado") %>%
  group_by(daytime, month, drunk_dr) %>%
  summarize(accidents = n())
```

As a note, you may want to create a table (for example, for a report) from the data at this stage. You could use `unite` then `spread` to do this pretty easily:

```{r check5a}
accident %>%
  filter(state_name == "Colorado") %>%
  mutate(daytime = factor(daytime, labels = c("Nighttime", "Daytime")),
         drunk_dr = factor(drunk_dr, 
                           labels = c("Not drunk driving", "Drunk driving"))) %>% 
  group_by(daytime, month, drunk_dr) %>%
  summarize(accidents = n()) %>% 
  ungroup() %>% 
  unite(category, daytime, drunk_dr, sep = " / ") %>% 
  spread(key = category, value = accidents) %>% 
  knitr::kable()
```

Write a function that inputs a dataframe (`df`) and outputs this type of summary dataframe (like the one just created for Colorado). You can do that with the following code. Note that, because it inputs a dataframe and outputs a dataframe, you can include it in a pipeline. 

```{r}
summarize_fars <- function(df){
  df %>%
    group_by(daytime, month, drunk_dr) %>%
    summarize(accidents = n())
}
```

Once you've written the function, see if you can figure out what the following code does. This code limits the data to data from four states and then applies the `summarize_fars` function that you just wrote to the subset of data from each state. Finally, since we `nest` to do that, the pipeline includes some lines to `unnest` the data to get back to an unnested data frame:

```{r check4a, eval = FALSE}
library(purrr)

accident %>% 
  filter(state_name %in% c("Colorado", "Texas", "California", "New York")) %>% 
  group_by(state_name) %>%
  nest() %>% 
  mutate(summary = map(data, summarize_fars)) %>% 
  select(-data) %>% 
  unnest() 
```

Write code to create boxplots for Colorado of the distribution of total accidents within each month. Create separate boxplots for daytime and nighttime accidents, and facet by whether the accident was related to drunk driving. You can do that with this code:

```{r check3a, fig.width = 6, fig.height = 3, fig.align = "center"}
accident %>%
  filter(state_name == "Colorado") %>%
  mutate(drunk_dr = factor(drunk_dr, labels = c("Unrelated to\ndrunk driving",
                                                "Related to\ndrunk driving")),
         daytime = factor(daytime, labels = c("Nighttime", "Daytime"))) %>%
  group_by(daytime, month, drunk_dr) %>%
  summarize(accidents = n()) %>%
  ggplot(aes(x = daytime, y = accidents, group = daytime)) + 
  geom_boxplot() + 
  facet_wrap(~ drunk_dr, ncol = 2) +
  xlab("Time of day") + ylab("# of monthly accidents") + 
  ggtitle(paste("Fatal accidents in", "Colorado", "in 2015"))
```


Now write a function called `plot_fars` to create a plot like the one you just made for Colorado for any dataframe with the format of `accident` (i.e., same number, types, and names of columns). Test it on subsets of the data for several states (Colorado, Texas, California, and New York). (*Hint*: To get a function to print out a plot created with ggplot, you must explicitly print the plot object. For example, you could assign the plot to `fars_plot`, and then you would run `print(fars_plot)` within your loop as the last step.) 

```{r check2a, echo = FALSE, fig.width = 6, fig.height = 3, fig.align = "center"}
plot_fars <- function(df){
  fars_plot <- df %>%
    mutate(drunk_dr = factor(drunk_dr, labels = c("Unrelated to\ndrunk driving",
                                                  "Related to\ndrunk driving")),
           daytime = factor(daytime, labels = c("Nighttime", "Daytime"))) %>%
    group_by(daytime, month, drunk_dr) %>%
    summarize(accidents = n()) %>%
    ggplot(aes(x = daytime, y = accidents, group = daytime)) +
    geom_boxplot() +
    facet_wrap(~ drunk_dr, ncol = 2) +
    xlab("Time of day") + ylab("# of monthly accidents") 
  fars_plot
}
```

Notice how similar this function is to the code you wrote in the previous step. 

Once you have written this function, what happens when you run the following code? The following code applies this function to the subset of data from each of four states. The output (`state_plots`) is a nested dataframe, where the new `plots` column is a list of `ggplot` objects. If you run `print` on this list, it will print each of these plots out separately (use the arrow buttons in the "Plots" Pane in RStudio to browse through these plots).

```{r check1a, fig.width = 6, fig.height = 3, fig.align = "center", eval = FALSE}
library(purrr)

state_plots <- accident %>% 
  filter(state_name %in% c("Colorado", "Texas", "California", "New York")) %>% 
  group_by(state_name) %>%
  nest() %>% 
  mutate(plots = map(data, plot_fars)) %>% 
  select(state_name, plots)

class(state_plots)
class(state_plots[["plots"]])
class(state_plots[["plots"]][[1]])
state_plots[["plots"]][[1]]$plot
```

Install the `cowplot` package (this is a `ggplot2` extension) and then try running the following code. What happens? The `plot_grid` function, if you input a list with `ggplot` objects using the `plotlist` argument, will print all the plots out on the same page. 

```{r fig.width = 12, fig.height = 8, fig.align = "center", eval = FALSE}
library(cowplot)
library(gtable)
plot_grid(plotlist = state_plots[["plots"]], 
          ncol = 2, labels = "AUTO")

```

### First steps in mapping 

Next, you'll try out some mapping with this FARS data. 

- Read in and clean up the FARS data and save it to an R object called `accident`. The `accident` data frame should include location (longitude and latitude), state, and whether the accident involved drunk driving. Once you're done cleaning, the dataset should look like this: 

```{r ccs, echo = FALSE, message = FALSE, warning = FALSE}
state_fips <- read_delim("http://www2.census.gov/geo/docs/reference/state.txt",
                         delim = "|") %>%
  dplyr::rename(state = STATE,
                state_name = STATE_NAME) %>%
  dplyr::select(state, state_name) %>%
  dplyr::mutate(state = as.integer(state))

accident <- read_csv("data/accident.csv") %>%
  dplyr::select(STATE, LATITUDE, LONGITUD, DRUNK_DR) %>%
  dplyr::rename(state = STATE,
                lat = LATITUDE,
                long = LONGITUD,
                drunk_dr = DRUNK_DR) %>%
  dplyr::mutate(drunk_dr = drunk_dr > 0) %>%
  dplyr::left_join(state_fips, by = "state") %>%
  dplyr::select(-state)
accident %>% slice(1:5)
```

- Next, create another R object with state-specific summaries. This object should be a data frame called `state_summaries` that gives the total number of fatal accidents in each state and the percent of all fatal accidents related to drunk driving in each state. The `state_summaries` data frame should look like this when you are done cleaning: 

```{r cct, echo = FALSE}
state_summaries <- accident %>%
  dplyr::group_by(state_name) %>%
  dplyr::summarize_(n = ~ n(),
            perc_drunk_dr = ~ 100 * mean(drunk_dr)) # Because `drunk_dr` is 
                                            # 0 / 1, the mean is the percent of 
                                            # values where `drunk_dr` == 1.
state_summaries %>% slice(1:5)
```

- Create the following state-level choropleths of number of fatal accidents in 2015 in each state and of the percent of fatal accidents linked to drunk driving in each state. The quickest way to do this is with the `choroplethr` package. 

```{r ccu, echo = FALSE, message = FALSE, warning = FALSE}
# With `choroplethr` package
library(choroplethr)
state_summaries %>%
  dplyr::mutate(state_name = str_to_lower(state_name)) %>%
  dplyr::rename(region = state_name,
                value = n) %>%
  state_choropleth(title = "Fatal accidents by state, 2015",
                   legend = "# of fatal accidents")

state_summaries %>%
  dplyr::mutate(state_name = str_to_lower(state_name)) %>%
  dplyr::rename(region = state_name,
                value = perc_drunk_dr) %>%
  state_choropleth(title = "Percent of fatal accidents linked\nto drunk driving, 2015",
                   legend = "% of fatal accidents\nlinked to drunk driving")
```

- Now, you will be using the latitude and longitude of each accident to plot accident locations within a state. Check if the columns for latitude and longitude need more cleaning (spoiler alert--- they do). Filter out any values that could not reasonably be within the 50 U.S. states and D.C. 

```{r ccv, echo = FALSE}
# It turns out that values like 77.7777, 88.8888, and 99.9999 are used as 
# missing values of latitude (similar for 777.777, etc., for longitude)
accident <- accident %>%
  dplyr::filter(lat < 75 & long < 777)
```

- Map the locations of fatal accidents in Texas in 2015 on top of a Google Map base map that shows major roads. An example map is shown below. (*Hint:* Use the `get_map` and `ggmap` functions for this part.)

```{r ccw, echo = FALSE, message = FALSE, warning = FALSE, eval = FALSE}
texas <- get_map(location = "texas", zoom = 6, maptype = "roadmap")
ggmap(texas, extent = "device") + 
  geom_point(data = dplyr::filter(accident, state_name == "Texas"), 
             aes(x = long, y = lat), alpha = 0.2, size = 0.5,
             color = "red")
```


- Create a function that will take three inputs: `datafr`, a data frame like `accident` with fatal accident data; `which_state`, a state name; and `drunk_dr`, a logical value (TRUE / FALSE) specifying whether to create separate maps for accidents that were and were not linked to drunk driving. This function should output a map (or two maps if `drunk_dr` is set to TRUE) with points for all fatal accidents in the state. Use `map_data` and create the map yourself, rather than using `choroplethr` for this question. Examples of calling this function are shown below.

```{r ccx, echo = FALSE}
library(maps)
map_fatal_accidents <- function(datafr = accident, which_state,
                                drunk_dr = FALSE){
  state_accidents <- datafr %>%
    dplyr::filter(state_name == which_state)
  state_map_data <- map_data("county", region = which_state)
  
  accident_map <- ggplot2::ggplot(state_map_data,
                                  ggplot2::aes(x = long, y = lat, 
                                               group = subregion)) + 
    ggplot2::geom_polygon(color = "gray", fill = NA) + 
    ggplot2::theme_void() + 
    ggplot2::geom_point(data = state_accidents, 
                        ggplot2::aes(x = long, y = lat, group = NULL),
                        alpha = 0.5, size = 0.7 )
  
  if(drunk_dr){
    accident_map <- accident_map + 
      ggplot2::facet_wrap(~ drunk_dr, ncol = 2)
  }
  
  accident_map + coord_map()
}
```

```{r ccy, message = FALSE, warning = FALSE, fig.width = 4, fig.height = 2.75, fig.align = "center"}
map_fatal_accidents(accident, which_state = "Colorado")
```

```{r ccz, message = FALSE, warning = FALSE, fig.width = 4.3, fig.height = 4.5, fig.align = "center"}
accident %>% 
  map_fatal_accidents(which_state = "Texas") 
```

```{r cda, message = FALSE, warning = FALSE, fig.width = 8, fig.height = 2.75, fig.align = "center"}
accident %>% 
  map_fatal_accidents(which_state = "Colorado", drunk_dr = TRUE)
```

```{r cdb, message = FALSE, warning = FALSE, fig.width = 8.6, fig.height = 4.5, fig.align = "center"}
map_fatal_accidents(accident, which_state = "Texas",
                    drunk_dr = TRUE)
```
